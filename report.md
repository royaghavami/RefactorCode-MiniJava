# RefactorCode-MiniJava

## گزارش کار
### الگوی Facade
- در الگوی طراحی فاساد (Facade Design Pattern)، یک رابط ساده و یکپارچه برای دسترسی به یک زیرسیستم پیچیده ارائه می‌شود. این الگو، یک لایه واسط را برای کاربر ارائه می دهد که با استفاده از آن، کاربر می تواند با سیستم بدون نیاز به آگاهی از جزئیات پیچیده آن ارتباط برقرار کند. کامیت مربوطه حاوی دو فایل CodeGeneratorFacade.js داخل فولدر codeGenerator و ScannerFacade.js داخل فولدر scanner است که هردو واسط های ساده‌ای هستند که دسترسی به توابع مختلف  codegenerator و scanner را فراهم می‌کنند. این واسط ها می‌توانند عملیات مربوط به تولید کد را مدیریت کرده و از جزئیات پیچیده آنها محافظت کنند.
- ![Screenshot 2023-08-11 162344](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/e449fa2f-3651-4f41-a88b-ffc455e0f42a)
- ![Screenshot 2023-08-11 162433](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/1a345287-8d02-490a-96c6-af0bcbd59dfd)
حال در خود کلاس Parser داریم:
- ![Screenshot 2023-08-11 162455](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/edb4dd0a-6401-4161-a668-02c27d679179)

### الگوی Replace Conditional with Polymorphism
- این تکنیک به اصل "بگو و نپرس کن" (Tell-Don't-Ask) پایبند است: به جای پرسیدن از یک شی درباره وضعیتش و سپس انجام عملیات بر اساس آن، بهتر است به شی بگویید چه کاری باید انجام دهد و اجازه دهید خودش تصمیم بگیرد چگونه این کار را انجام دهد. به علاوه، این تکنیک کدهای تکراری را حذف می‌کند و اگر نیاز به اضافه کردن نوع اجرای جدیدی داشته باشید، تنها کافیست یک زیرکلاس جدید اضافه کنید بدون اینکه به کد موجود دست بزنید (اصل باز/بسته Open/Closed)
- ![Screenshot 2023-08-11 215036](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/3f8931d9-eb68-4197-bc94-afeea267465f)
- ![Screenshot 2023-08-11 215112](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/fd65c4d1-690a-488f-b689-de6619f0ac78)

### الگوی Seperate Query from Modifier
- در این اصل کدهای مسئول دریافت داده ها را از کدهایی که چیزی را در داخل یک شی تغییر می دهد جدا میکنیم.

  ### در ادامه دو کامیت مربوط به Self Encapsulated Field قرار دارد که در آن برای فیلدهای private از getter استفاده کردیم، یک کامیت مربوط به قرار دادن default برای switch statement و یک کامیت نیز برای loose coupling که به جای ArrayList از List استفاده کردیم و بعدا هنگام new کردن از ArrayList استفاده می کنیم.
  



## پاسخ سوالات
## سوال 1
### کد تمیز: 
کدی است که با استفاده از استانداردها و روش‌های مناسب نوشته شده و ساختاری خوانا و قابل فهم دارد. کد تمیز معمولاً آسان‌تر قابل نگهداری، توسعه و تغییر است و باعث افزایش کیفیت و قابلیت‌های برنامه می‌شود.

### بدهی فنی: 
بدهی فنی به معنای وجود مشکلات فنی و نقص‌هایی در یک پروژه یا سیستم است که نیاز به رفع دارند. این مشکلات ممکن است شامل عدم رعایت استانداردها، ضعف در عملکرد، خطاهای منطقی و غیره باشند. بدهی فنی معمولاً منجر به کاهش کیفیت و قابلیت اطمینان سیستم می‌شود و نیازمند تلاش برای رفع آنها است.

### بوی بد: 
در مفهوم برنامه‌نویسی، بوی بد به مشکلات و نقص‌هایی در ساختار و طراحی کد اشاره دارد که ممکن است علائمی از وجود بدهی فنی باشند، اما بر خلاف بدهی فنی که مشکلات فنی قابل مشاهده هستند، بوی بد ممکن است برای برنامه‌نویسان آشنا نباشد. بوی بد معمولاً توسط تحلیل‌گران و برنامه‌نویسان حرفه‌ای شناسایی می‌شود و نشانه‌هایی از نقاط ضعف و مشکلات پنهان در کد می‌باشد.

## سوال 2
1.	بلوترها (Bloaters): بوهای بلوترها به نواقصی در طراحی و پیاده‌سازی کد اشاره می‌کنند که منجر به افزایش پیچیدگی، کاهش قابلیت فهم، و کاهش توسعه و نگهداری آسان کد می‌شود. مثال‌هایی از آنها عبارتند از: متدهای طولانی، کلاس‌های بزرگ، و استفاده نادرست از نوع داده‌های ابتدایی.
2.	سو استفاده از شیء-گرایی (Object-Orientation Abusers): این بوها به نقاط ضعف در استفاده از مفاهیم شیء-گرایی در طراحی نرم‌افزار اشاره می‌کنند. مثال‌هایی از آنها شامل: استفاده نامناسب از کلاس‌های جایگزین با روابط متفاوت، استفاده نادرست از بیانیه‌های switch، و استفاده از فیلدهای موقتی است.
3.	مانع‌های تغییر (Change Preventers): این بوها به عواملی اشاره می‌کنند که مانع تغییرات و اصلاحات در کد می‌شوند. مثال‌هایی از آنها شامل: تغییر منحرف که منجر به انتشار تغییرات مرتبط در نقاط مختلف کد می‌شود، سلسله مراتب ارث موازی که منجر به پیچیدگی و ابهام در ساختار ارث بری می‌شود، و جراحی شاتگانی که نیاز به تغییرات گسترده در مکان‌های مختلف برنامه را ایجاد می‌کند.
4.	غیرضروری‌ها (Dispensables): این بوها به کدهای غیرضروری و مجموعه‌ای از عناصر که به کد اضافه می‌شوند اشاره می‌کنند و می‌توانند خوانایی، قابلیت تست و نگهداری کد را کاهش دهند. مثال‌هایی از آنها شامل: توضیحات بیش از حد، کدهای تکراری، کلاس‌های داده، و کدهای مرده است.
5.	اتصال‌گرها (Couplers): این بوها به نقاط ضعفی در اتصال و وابستگی بین کلاس‌ها اشاره می‌کنند. مثال‌هایی از آنها شامل: حسادت قابلیت که منجر به وابستگی نامناسب به ویژگی‌های کلاس‌های دیگر می‌شود.


## سوال 3
### بوی بد "Lazy Class" در دسته‌بندی "بوهای بد ساختاری" قرار می‌گیرد.
### برای برطرف‌کردن بوی بد "Lazy Class"، می‌توان از بازآرایی‌های زیر استفاده کرد:
-	مفهوم Inline Class: اگر کلاسی از لحاظ وظیفه و مسئولیت خود بی‌ارتباط و بی‌اهمیت به نظر می‌رسد، می‌توان محتویات آن را در کلاس دیگری inline کرد.
-	انجام دادن Collapse Hierarchy: اگر کلاسی از سلسله مراتب کلاس‌ها استفاده می‌کند و در واقع تنها یک سطح از سلسله مراتب را تشکیل می‌دهد، می‌توان سلسله مراتب را کاهش داده و کلاس‌ها را ترکیب کرد.
### بوی بد "Lazy Class" در مواقع زیر می‌تواند نادیده گرفته شود:
-	وقتی کلاس به‌طور کامل در حال استفاده است و وظایف و مسئولیت‌های خود را به خوبی اجرا می‌کند.
-	وقتی کلاس برای توسعه و تغییرات آینده طراحی شده است و برای افزودن وظایف بیشتر آماده است.
-	وقتی مسئولیت‌های کلاس به صورت موقتی و محدود به دوره‌های زمانی خاصی است.
