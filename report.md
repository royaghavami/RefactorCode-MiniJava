# RefactorCode-MiniJava

## گزارش کار
### الگوی Facade
- در الگوی طراحی فاساد (Facade Design Pattern)، یک رابط ساده و یکپارچه برای دسترسی به یک زیرسیستم پیچیده ارائه می‌شود. این الگو، یک لایه واسط را برای کاربر ارائه می دهد که با استفاده از آن، کاربر می تواند با سیستم بدون نیاز به آگاهی از جزئیات پیچیده آن ارتباط برقرار کند. کامیت مربوطه حاوی دو فایل CodeGeneratorFacade.js داخل فولدر codeGenerator و ScannerFacade.js داخل فولدر scanner است که هردو واسط های ساده‌ای هستند که دسترسی به توابع مختلف  codegenerator و scanner را فراهم می‌کنند. این واسط ها می‌توانند عملیات مربوط به تولید کد را مدیریت کرده و از جزئیات پیچیده آنها محافظت کنند.
- ![Screenshot 2023-08-11 162344](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/e449fa2f-3651-4f41-a88b-ffc455e0f42a)
- ![Screenshot 2023-08-11 162433](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/1a345287-8d02-490a-96c6-af0bcbd59dfd)
حال در خود کلاس Parser داریم:
- ![Screenshot 2023-08-11 162455](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/edb4dd0a-6401-4161-a668-02c27d679179)

### الگوی Replace Conditional with Polymorphism
- این تکنیک به اصل "بگو و نپرس کن" (Tell-Don't-Ask) پایبند است: به جای پرسیدن از یک شی درباره وضعیتش و سپس انجام عملیات بر اساس آن، بهتر است به شی بگویید چه کاری باید انجام دهد و اجازه دهید خودش تصمیم بگیرد چگونه این کار را انجام دهد. به علاوه، این تکنیک کدهای تکراری را حذف می‌کند و اگر نیاز به اضافه کردن نوع اجرای جدیدی داشته باشید، تنها کافیست یک زیرکلاس جدید اضافه کنید بدون اینکه به کد موجود دست بزنید (اصل باز/بسته Open/Closed)
- ![Screenshot 2023-08-11 215036](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/3f8931d9-eb68-4197-bc94-afeea267465f)
- ![Screenshot 2023-08-11 215112](https://github.com/royaghavami/RefactorCode-MiniJava/assets/59202308/fd65c4d1-690a-488f-b689-de6619f0ac78)

### الگوی Seperate Query from Modifier
- این اصل به ما می گوید که کدهای مسئول دریافت داده ها را از کدهایی که چیزی را در داخل یک شی تغییر می دهد جدا کنیم.

  ### در ادامه دو کامیت مربوط به Self Encapsulated Field قرار دارد که در آن برای فیلدهای private از getter استفاده کردیم، یک کامیت مربوط به قرار دادن default برای switch statement و یک کامیت نیز برای loose coupling که به جای ArrayList از List استفاده کردیم و بعدا هنگام new کردن از ArrayList استفاده می کنیم.
  



## پاسخ سوالات
1- 
### کد تمیز: 
کدی است که با استفاده از استانداردها و روش‌های مناسب نوشته شده و ساختاری خوانا و قابل فهم دارد. کد تمیز معمولاً آسان‌تر قابل نگهداری، توسعه و تغییر است و باعث افزایش کیفیت و قابلیت‌های برنامه می‌شود.

### بدهی فنی: 
بدهی فنی به معنای وجود مشکلات فنی و نقص‌هایی در یک پروژه یا سیستم است که نیاز به رفع دارند. این مشکلات ممکن است شامل عدم رعایت استانداردها، ضعف در عملکرد، خطاهای منطقی و غیره باشند. بدهی فنی معمولاً منجر به کاهش کیفیت و قابلیت اطمینان سیستم می‌شود و نیازمند تلاش برای رفع آنها است.

### بوی بد: 
در مفهوم برنامه‌نویسی، بوی بد به مشکلات و نقص‌هایی در ساختار و طراحی کد اشاره دارد که ممکن است علائمی از وجود بدهی فنی باشند، اما بر خلاف بدهی فنی که مشکلات فنی قابل مشاهده هستند، بوی بد ممکن است برای برنامه‌نویسان آشنا نباشد. بوی بد معمولاً توسط تحلیل‌گران و برنامه‌نویسان حرفه‌ای شناسایی می‌شود و نشانه‌هایی از نقاط ضعف و مشکلات پنهان در کد می‌باشد.

2- 
### بوی بد "Lazy Class" در دسته‌بندی "بوهای بد ساختاری" قرار می‌گیرد.
### برای برطرف‌کردن بوی بد "Lazy Class"، می‌توان از بازآرایی‌های زیر استفاده کرد:
-	مفهوم Inline Class: اگر کلاسی از لحاظ وظیفه و مسئولیت خود بی‌ارتباط و بی‌اهمیت به نظر می‌رسد، می‌توان محتویات آن را در کلاس دیگری inline کرد.
-	انجام دادن Collapse Hierarchy: اگر کلاسی از سلسله مراتب کلاس‌ها استفاده می‌کند و در واقع تنها یک سطح از سلسله مراتب را تشکیل می‌دهد، می‌توان سلسله مراتب را کاهش داده و کلاس‌ها را ترکیب کرد.
### بوی بد "Lazy Class" در مواقع زیر می‌تواند نادیده گرفته شود:
-	وقتی کلاس به‌طور کامل در حال استفاده است و وظایف و مسئولیت‌های خود را به خوبی اجرا می‌کند.
-	وقتی کلاس برای توسعه و تغییرات آینده طراحی شده است و برای افزودن وظایف بیشتر آماده است.
-	وقتی مسئولیت‌های کلاس به صورت موقتی و محدود به دوره‌های زمانی خاصی است.
